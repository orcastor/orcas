# HTTP协议性能对比报告

- [English](HTTP_PROTOCOL_COMPARISON_REPORT.md) | [中文](HTTP_PROTOCOL_COMPARISON_REPORT.zh.md)

## 测试环境

- **操作系统**: macOS
- **架构**: arm64
- **CPU**: Apple Silicon M4 Pro
- **Go版本**: Go 1.18+
- **测试框架**: Go testing 包
- **测试日期**: 2025-11-11
- **批量写入**: 已启用 (ORCAS_BATCH_WRITE_ENABLED=true)
- **批量写入阈值**: 64KB
- **TLS开销**: 已排除（HTTP/2使用h2c明文，HTTP/3使用最小化TLS配置）

## 测试场景

### 场景1：小文件（1KB）- 10并发，100操作

| 协议 | 操作数/秒 | 吞吐量 (MB/s) | 提升 |
|------|----------|--------------|------|
| **HTTP/1.1** | 1614.69 | 1.58 | 基准 |
| **HTTP/2 (h2c)** | 1510.15 | 1.47 | -6.47% |
| **HTTP/3 (最小化TLS)** | 1559.88 | 1.52 | -3.39% |

**分析：**
- HTTP/1.1在此场景下性能**比HTTP/2好6.47%**，**比HTTP/3好3.39%**
- HTTP/2相对HTTP/1.1下降6.47%（协议开销，TLS已排除）
- HTTP/3相对HTTP/1.1下降3.39%（QUIC开销，最小化TLS）
- HTTP/3相对HTTP/2提升3.29%
- 排除TLS开销后，HTTP/2和HTTP/3性能更接近HTTP/1.1
- HTTP/3在此场景下表现优于HTTP/2

**关键发现：**
- 对于小文件低并发场景，HTTP/1.1仍然性能最好
- 排除TLS开销后，HTTP/2和HTTP/3与HTTP/1.1的差距大幅缩小
- HTTP/3在低并发场景下表现略优于HTTP/2
- 排除TLS后，协议开销很小

### 场景2：小文件（1KB）- 50并发，500操作

| 协议 | 操作数/秒 | 吞吐量 (MB/s) | 提升 |
|------|----------|--------------|------|
| **HTTP/1.1** | 1729.30 | 1.69 | 基准 |
| **HTTP/2 (h2c)** | 1800.95 | 1.76 | **+4.14%** ⭐ |
| **HTTP/3 (最小化TLS)** | 1817.18 | 1.77 | **+5.08%** ⭐ |

**分析：**
- HTTP/2在高并发时显示**4.14%的性能提升**
- HTTP/3在高并发时显示**5.08%的性能提升**
- HTTP/3相对HTTP/2提升0.90%
- 多路复用优势在高并发时显现
- HTTP/2和HTTP/3的优势随并发请求数增加而增加
- HTTP/3在高并发场景下表现最佳

### 场景3：中等文件（64KB）- 10并发，50操作

| 协议 | 操作数/秒 | 吞吐量 (MB/s) | 提升 |
|------|----------|--------------|------|
| **HTTP/1.1** | 1436.86 | 89.80 | 基准 |
| **HTTP/2 (h2c)** | 1175.54 | 73.47 | -18.19% |
| **HTTP/3 (最小化TLS)** | 1152.17 | 72.01 | -19.81% |

**分析：**
- HTTP/2相对HTTP/1.1下降18.19%（中等文件）
- HTTP/3相对HTTP/1.1下降19.81%（中等文件）
- 对于中等文件低并发场景，HTTP/1.1性能最好
- 协议开销在较大文件时变得更加显著
- 头部压缩的优势在本地测试中可能无法抵消协议开销

## 性能特征

### HTTP/1.1
- **优势**: 本地测试开销低，无需TLS
- **劣势**: 无多路复用，可能存在队头阻塞
- **适用场景**: 本地测试，简单场景，低并发

### HTTP/2
- **状态**: ✅ 已完全实现并测试（使用h2c明文，TLS已排除）
- **优势**: 多路复用，头部压缩，高并发性能更好
- **劣势**: 低并发场景下的协议开销，设置更复杂
- **适用场景**: 高并发，网络场景，生产环境
- **性能**: 在高并发场景下显示4.14%的提升（50并发）

### HTTP/3
- **状态**: ✅ 已完全实现并测试（使用最小化TLS配置）
- **优势**: 更快的连接建立，更好的多路复用，基于UDP，避免TCP队头阻塞
- **劣势**: QUIC协议开销（协议要求必须使用TLS），设置更复杂
- **适用场景**: 高延迟网络，移动连接，有丢包的场景，高并发场景
- **性能**: 在高并发场景下显示5.08%的提升（50并发），所有协议中表现最佳

## 建议

1. **本地测试（低并发）**: 使用HTTP/1.1以获得简单性和最佳性能
2. **生产环境（高并发）**: 使用HTTP/2（h2c）或HTTP/3以获得更好的并发性能
3. **高并发场景**: HTTP/3表现最佳（+5.08%），其次是HTTP/2（+4.14%）
4. **中等/大文件（低并发）**: HTTP/1.1性能最好，因为协议开销更低
5. **真实网络场景**: HTTP/2和HTTP/3的优势在网络延迟下会更加明显
6. **TLS排除**: 测试使用h2c（HTTP/2明文）和最小化TLS（HTTP/3）来排除TLS开销，确保公平对比

## 总结

**关键洞察：**
- **低并发（10），小文件**: HTTP/1.1性能最好（比HTTP/2好6.47%，比HTTP/3好3.39%）
- **高并发（50），小文件**: HTTP/3表现最佳（+5.08%），其次是HTTP/2（+4.14%）
- **低并发（10），中等文件**: HTTP/1.1性能最好（比HTTP/2和HTTP/3好18-20%）
- **TLS排除影响**: 排除TLS开销后，HTTP/2和HTTP/3性能更接近HTTP/1.1
- **并发数很重要**: HTTP/2和HTTP/3的优势随并发级别显著增加
- **HTTP/3性能**: 在高并发场景下表现最佳（+5.08% vs HTTP/1.1）
- **协议排名（低并发）**: HTTP/1.1 > HTTP/3 > HTTP/2
- **协议排名（高并发）**: HTTP/3 > HTTP/2 > HTTP/1.1

## 运行测试

```bash
# 运行HTTP协议对比测试
cd s3
ORCAS_BATCH_WRITE_ENABLED=true go test -v -run TestHTTPProtocolComparison -timeout 5m

# 运行全面对比测试
ORCAS_BATCH_WRITE_ENABLED=true go test -v -run TestHTTPProtocolComparisonComprehensive -timeout 10m
```

## 注意事项

- **TLS开销已排除**: HTTP/2使用h2c（明文）完全排除TLS开销。HTTP/3使用最小化TLS配置（QUIC协议要求必须使用TLS）。
- **低并发**: HTTP/1.1在低并发场景下性能最好，因为协议开销更低
- **高并发**: HTTP/3和HTTP/2显示显著优势（+5.08%和+4.14%）
- **中等文件**: 协议开销在较大文件时变得更加显著（本地测试）
- **真实网络场景**: HTTP/2和HTTP/3的优势在网络延迟和丢包下会更加明显
- **HTTP/3测试**: 需要安装quic-go库：`go get github.com/quic-go/quic-go/http3`

## 实现状态

- ✅ **HTTP/1.1**: 已完全实现并测试
- ✅ **HTTP/2**: 已完全实现并测试
- ✅ **HTTP/3**: 已完全实现并测试（使用quic-go库）

**最新测试结果（TLS开销已排除）：**

**小文件（1KB），10并发：**
- HTTP/1.1: 1614.69 ops/sec
- HTTP/2 (h2c): 1510.15 ops/sec (-6.47%)
- HTTP/3 (最小化TLS): 1559.88 ops/sec (-3.39%)

**小文件（1KB），50并发：**
- HTTP/1.1: 1729.30 ops/sec
- HTTP/2 (h2c): 1800.95 ops/sec (+4.14%) ⭐
- HTTP/3 (最小化TLS): 1817.18 ops/sec (+5.08%) ⭐

**中等文件（64KB），10并发：**
- HTTP/1.1: 1436.86 ops/sec
- HTTP/2 (h2c): 1175.54 ops/sec (-18.19%)
- HTTP/3 (最小化TLS): 1152.17 ops/sec (-19.81%)

**注意**：排除TLS开销后，HTTP/2和HTTP/3性能大幅改善，特别是在高并发场景下。HTTP/3在高并发场景下表现最佳。

