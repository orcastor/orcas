# S3 性能测试报告

- [English](PERFORMANCE_TEST_REPORT.md) | [中文](PERFORMANCE_TEST_REPORT.zh.md)

## 测试环境

- **操作系统**: macOS
- **架构**: arm64
- **CPU**: Apple Silicon M4 Pro
- **Go版本**: Go 1.18+
- **测试框架**: Go testing 包配合 httptest
- **测试日期**: 2025-11-11
- **协议**: HTTP/1.1 (httptest)
- **批量写入阈值**: 64KB（基于性能测试优化）

## 最新性能测试结果

### 并发性能

**关键发现：**
- **单线程性能**：1KB提升54.9%，4KB提升153.0%，64KB提升100.1%
- **并发性能**：批量写入在并发场景下表现更优，1KB文件在并发100时提升120.5%，4KB文件在并发10时提升117.3%，64KB文件在并发10时提升76.7%
- **优化阈值**：64KB是批量写入的阈值上限（≤64KB可使用批量写入），超过64KB的文件批量写入不生效
- **并发优势**：批量写入在高并发场景下优势更明显，能显著减少I/O操作和元数据开销
- **大文件性能**：10MB文件在并发100时达到212.56 ops/sec，吞吐量2125.64 MB/s

## 性能特征

### 1. 批量写入优化

S3服务利用批量写入优化处理小文件：

- **自动启用**：对于小于等于64KB的文件，自动使用批量写入
- **批量打包**：多个小文件打包到单个数据块中
- **批量元数据**：批量写入DataInfo和ObjectInfo，减少数据库操作
- **配置控制**：通过`ORCAS_BATCH_WRITE_ENABLED`控制（默认启用）

**优势：**
- 减少I/O操作50-80%
- 提升小文件写入吞吐量50-90%
- 减少数据库事务开销

### 批量写入性能对比

批量写入开启与关闭的性能对比：

#### 单线程性能

| 场景 | 数据大小 | 并发数 | 批量写入开启 | 批量写入关闭 | 差异 | 提升/下降 |
|------|---------|--------|-------------|-------------|------|----------|
| **小文件** | 1KB | 1 | 409.33 ops/sec | 264.17 ops/sec | +145.16 | **54.9% ↑** |
| **小文件** | 4KB | 1 | 628.82 ops/sec | 248.68 ops/sec | +380.14 | **153.0% ↑** |
| **小文件** | 64KB | 1 | 481.97 ops/sec | 240.73 ops/sec | +241.24 | **100.1% ↑** |

#### 并发性能（批量写入开启）

| 场景 | 数据大小 | 并发数 | 操作数/秒 | 吞吐量 (MB/s) | 平均延迟 |
|------|---------|--------|----------|--------------|---------|
| **小文件** | 1KB | 10 | 1226.45 ops/sec | 1.20 MB/s | 815.36µs |
| **小文件** | 1KB | 50 | 1545.30 ops/sec | 1.51 MB/s | 647.12µs |
| **小文件** | 1KB | 100 | 1589.19 ops/sec | 1.55 MB/s | 629.25µs |
| **小文件** | 4KB | 10 | 1583.77 ops/sec | 6.19 MB/s | 631.40µs |
| **小文件** | 4KB | 50 | 1481.56 ops/sec | 5.79 MB/s | 674.96µs |
| **小文件** | 4KB | 100 | 1297.06 ops/sec | 5.07 MB/s | 770.98µs |
| **小文件** | 64KB | 10 | 1276.83 ops/sec | 79.80 MB/s | 783.19µs |
| **小文件** | 64KB | 50 | 973.31 ops/sec | 60.83 MB/s | 1.03ms |
| **小文件** | 64KB | 100 | 953.34 ops/sec | 59.58 MB/s | 1.05ms |

#### 并发性能（批量写入关闭）

| 场景 | 数据大小 | 并发数 | 操作数/秒 | 吞吐量 (MB/s) | 平均延迟 |
|------|---------|--------|----------|--------------|---------|
| **小文件** | 1KB | 10 | 740.06 ops/sec | 0.72 MB/s | 1.35ms |
| **小文件** | 1KB | 50 | 778.65 ops/sec | 0.76 MB/s | 1.28ms |
| **小文件** | 1KB | 100 | 720.86 ops/sec | 0.70 MB/s | 1.39ms |
| **小文件** | 4KB | 10 | 728.83 ops/sec | 2.85 MB/s | 1.37ms |
| **小文件** | 4KB | 50 | 805.42 ops/sec | 3.15 MB/s | 1.24ms |
| **小文件** | 4KB | 100 | 735.16 ops/sec | 2.87 MB/s | 1.36ms |
| **小文件** | 64KB | 10 | 722.57 ops/sec | 45.16 MB/s | 1.38ms |
| **小文件** | 64KB | 50 | 712.09 ops/sec | 44.51 MB/s | 1.40ms |
| **小文件** | 64KB | 100 | 726.77 ops/sec | 45.42 MB/s | 1.38ms |

#### 大文件性能（批量写入不生效，> 64KB）

| 场景 | 数据大小 | 并发数 | 操作数/秒 | 吞吐量 (MB/s) | 平均延迟 |
|------|---------|--------|----------|--------------|---------|
| **大文件** | 10MB | 10 | 106.30 ops/sec | 1062.99 MB/s | 9.41ms |
| **大文件** | 10MB | 50 | 164.30 ops/sec | 1643.00 MB/s | 6.09ms |
| **大文件** | 10MB | 100 | 212.56 ops/sec | 2125.64 MB/s | 4.70ms |

**关键发现：**

**单线程性能：**
- **小文件（1KB）**：批量写入提供**54.9%的性能提升**（1.5倍）
- **小文件（4KB）**：批量写入提供**153.0%的性能提升**（2.5倍）
- **小文件（64KB）**：批量写入提供**100.1%的性能提升**（2.0倍）

**并发性能：**
- **1KB文件（并发10）**：批量写入开启 1226.45 ops/sec vs 关闭 740.06 ops/sec（**提升65.7%**）
- **1KB文件（并发50）**：批量写入开启 1545.30 ops/sec vs 关闭 778.65 ops/sec（**提升98.4%**）
- **1KB文件（并发100）**：批量写入开启 1589.19 ops/sec vs 关闭 720.86 ops/sec（**提升120.5%**）
- **4KB文件（并发10）**：批量写入开启 1583.77 ops/sec vs 关闭 728.83 ops/sec（**提升117.3%**）
- **4KB文件（并发50）**：批量写入开启 1481.56 ops/sec vs 关闭 805.42 ops/sec（**提升83.9%**）
- **4KB文件（并发100）**：批量写入开启 1297.06 ops/sec vs 关闭 735.16 ops/sec（**提升76.4%**）
- **64KB文件（并发10）**：批量写入开启 1276.83 ops/sec vs 关闭 722.57 ops/sec（**提升76.7%**）
- **64KB文件（并发50）**：批量写入开启 973.31 ops/sec vs 关闭 712.09 ops/sec（**提升36.7%**）
- **64KB文件（并发100）**：批量写入开启 953.34 ops/sec vs 关闭 726.77 ops/sec（**提升31.2%**）

**大文件性能分析：**
- **10MB文件（并发10）**：106.30 ops/sec，吞吐量 1062.99 MB/s，平均延迟 9.41ms
- **10MB文件（并发50）**：164.30 ops/sec，吞吐量 1643.00 MB/s，平均延迟 6.09ms
- **10MB文件（并发100）**：212.56 ops/sec，吞吐量 2125.64 MB/s，平均延迟 4.70ms
- 大文件性能随并发数线性增长，吞吐量在100并发时达到2.1 GB/s以上

**总结：**
- 批量写入在并发场景下表现更优，特别是小文件（1KB、4KB）
- 64KB文件在并发场景下仍能获得30-77%的性能提升
- 批量写入显著减少I/O操作和元数据开销，在高并发场景下优势更明显
- 大文件（> 64KB）使用直接写入路径，性能随并发数线性增长

**内存和GC影响：**
- 批量写入开启：由于缓冲，内存使用略高（14.17 MB vs 12.24 MB），GC次数相似（24 vs 23）
- 批量写入关闭：内存使用较低，GC次数相似

**建议：**
- ✅ **小文件（≤ 64KB）**：强烈推荐开启批量写入
  - **单线程**：1KB提升54.9%，4KB提升153.0%，64KB提升100.1%
  - **并发场景**：批量写入在并发场景下表现更优，1KB文件在并发100时提升120.5%，4KB文件在并发10时提升117.3%，64KB文件在并发10时提升76.7%
- ⚠️ **大文件（> 64KB）**：批量写入不生效，超过64KB的文件将使用直接写入路径

### 2. 分块存储

所有数据根据bucket的`ChunkSize`配置进行分块存储：

- **默认ChunkSize**：4MB
- **小文件**：直接存储为单个数据块
- **大文件**：自动分割为多个数据块
- **分片上传**：每个分片根据ChunkSize进行分块

### 3. 并发性能

S3服务展现出优秀的并发性能：

- **线性扩展**：性能随并发数几乎线性增长，最高支持100个goroutine
- **低延迟**：平均延迟随并发数增加而降低
- **高吞吐量**：100并发操作达到773.86 MB/s

## 测试场景

### 基础操作

1. **PutObject**：上传不同大小的对象（1KB、4KB、64KB等）
2. **GetObject**：下载对象（在并发场景中测试）
3. **ListObjects**：列出bucket中的对象
4. **HeadObject**：获取对象元数据
5. **DeleteObject**：删除对象

### 并发操作

1. **并发PutObject**：多个goroutine同时上传对象
2. **并发GetObject**：多个goroutine同时下载对象
3. **并发ListObjects**：多个goroutine同时列出对象

### 高级功能

1. **范围读取**：读取对象的指定字节范围
2. **分片上传**：分片上传大文件
3. **复制/移动操作**：在bucket之间复制和移动对象

## 性能指标

### 吞吐量分析

- **单线程**：16.88 MB/s（1MB对象）
- **10并发**：165.25 MB/s（**提升9.8倍**）
- **50并发**：520.87 MB/s（**提升30.9倍**）
- **100并发**：773.86 MB/s（**提升45.9倍**）

### 延迟分析

- **单线程**：59.25ms平均延迟
- **10并发**：6.05ms平均延迟（**降低89.8%**）
- **50并发**：1.92ms平均延迟（**降低96.8%**）
- **100并发**：1.29ms平均延迟（**降低97.8%**）

### 可扩展性

S3服务展现出优秀的可扩展性：

- 性能随并发数几乎线性增长
- 在100并发操作下无明显性能下降
- 通过批量写入优化实现高效的资源利用

## 配置选项

可通过环境变量调整性能：

```bash
# 启用/禁用批量写入（默认启用）
export ORCAS_BATCH_WRITE_ENABLED=true

# 批量写入文件大小阈值（默认64KB，基于测试优化）
export ORCAS_MAX_BATCH_WRITE_FILE_SIZE=65536  # 64KB

# 批量写入缓冲区窗口时间（默认10秒）
export ORCAS_WRITE_BUFFER_WINDOW_SEC=10

# 最大缓冲区大小（默认8MB）
export ORCAS_MAX_WRITE_BUFFER_SIZE=8388608

# 最大缓冲区写入次数（默认2048）
export ORCAS_MAX_WRITE_BUFFER_COUNT=2048
```

## 与VFS性能对比

S3服务性能建立在优化的VFS层之上：

- **VFS单线程**：6650 ops/sec
- **VFS并发（3）**：2903 ops/sec
- **S3单线程**：16.88 ops/sec（包含HTTP开销）
- **S3并发（100）**：773.86 ops/sec

**说明**：S3性能包含HTTP请求/响应开销、认证和S3 API处理，这解释了与VFS直接操作相比绝对数值较低的原因。

## 运行性能测试

```bash
# 运行所有性能测试
cd s3
go test -v -run TestPerformance

# 运行基准测试
go test -bench=. -benchmem -benchtime=3s

# 生成性能报告
go test -v -run TestPerformanceReport
```

### 何时使用批量写入

**推荐使用（批量写入开启）：**
- ✅ 小文件上传（≤ 64KB）- **强烈推荐**（1KB提升66-180%，4KB提升58-165%，64KB提升约11%）
- ✅ 高并发场景下的小文件（10-100并发）
- ✅ 大量小对象的工作负载

**不推荐使用（批量写入关闭）：**
- ❌ 实时关键上传
- ❌ 低延迟要求
- ❌ 单文件上传场景

## 秒传（Instant Upload）性能测试

### 测试环境
- **测试日期**: 最新测试（配置缓存优化后）
- **测试文件大小**: 10KB（主要测试），1KB-10MB（全面测试）
- **测试次数**: 50次上传（小文件），200次（1KB），100次（10KB），50次（100KB），20次（1MB），10次（10MB）

### 秒传 vs 普通上传性能对比

| 指标 | 秒传（重复数据） | 普通上传（唯一数据） | 性能提升 |
|------|----------------|-------------------|---------|
| **平均延迟** | 2.63ms | 3.45ms | **1.31x 更快** |
| **基准测试延迟** | 4.42ms/op | 6.46ms/op | **1.46x 更快** |
| **内存分配** | 6677 allocs/op | 15927 allocs/op | **减少58%** |
| **内存使用** | 5.37 MB/op | 6.54 MB/op | **减少18%** |
| **总时间（50次）** | 131.72ms | 172.37ms | **节省40.66ms** |

**关键发现：**
- ✅ **性能提升显著**：秒传比普通上传快 **31-46%**
- ✅ **内存优化**：内存分配减少 **58%**，内存使用减少 **18%**
- ✅ **小文件优势明显**：10KB文件测试显示秒传平均快 **813µs/次**

### 秒传开销分析（非去重文件）

对于无法去重的文件（唯一数据），秒传功能的性能开销：

| 文件大小 | 秒传平均延迟 | 基准平均延迟 | 时间开销 | CPU开销 | 内存开销 | 结论 |
|---------|------------|------------|---------|---------|---------|------|
| **1KB** | 4.82ms | 5.39ms | **-10.55%** | -568.67µs | **-94 KB** | ✅ 更快 |
| **10KB** | 5.69ms | 6.11ms | **-6.90%** | -422.12µs | **-52 KB** | ✅ 更快 |
| **100KB** | 5.90ms | 6.01ms | **-1.81%** | -108.91µs | **-22 KB** | ✅ 更快 |
| **1MB** | 8.16ms | 8.02ms | **+1.82%** | +145.64µs | **-8 KB** | ✅ 可接受 |
| **10MB** | 34.58ms | 30.35ms | **+13.94%** | +4.23ms | **+511 KB** | ✅ 可接受 |

**关键发现：**
- ✅ **小文件无开销**：1KB-100KB文件，秒传实际上**更快**（负开销）
- ✅ **中等文件开销极小**：1MB文件仅增加 **1.82%** 延迟，可忽略
- ✅ **大文件开销可接受**：10MB文件增加 **13.94%** 延迟，但内存优化（-94KB到+511KB）和去重优势明显
- ✅ **配置缓存优化生效**：使用ecache缓存后，小文件场景下秒传甚至更快

### 不同文件大小的秒传性能

| 文件大小 | 秒传延迟 | 数据ID复用 | 性能特征 |
|---------|---------|-----------|---------|
| **1KB** | 8.13ms | ✅ 成功 | 快速去重 |
| **10KB** | 8.64ms | ✅ 成功 | 快速去重 |
| **100KB** | 7.27ms | ✅ 成功 | 快速去重 |
| **1MB** | 15.52ms | ✅ 成功 | 中等去重 |

**分析：**
- 所有测试文件大小都能成功实现秒传（DataID复用）
- 小文件（1KB-100KB）秒传延迟在 **7-9ms** 范围内
- 中等文件（1MB）秒传延迟约 **15ms**，仍然非常快速

### 秒传性能优势总结

1. **去重场景（重复数据）**：
   - 性能提升 **31-46%**
   - 内存分配减少 **58%**
   - 延迟降低 **813µs-2.04ms/次**

2. **非去重场景（唯一数据）**：
   - 小文件（1KB-100KB）：**无开销甚至更快**（-1.81% 到 -10.55%）
   - 中等文件（1MB）：**开销极小**（+1.82%）
   - 大文件（10MB）：**开销可接受**（+13.94%）

3. **配置优化效果**：
   - 使用ecache缓存配置（10秒TTL）后，小文件场景下秒传性能甚至优于普通上传
   - 统一配置系统（`GetWriteConfig()`）减少了环境变量读取开销

### 秒传使用建议

**强烈推荐使用：**
- ✅ 重复文件上传场景（备份、同步等）
- ✅ 小文件上传（< 100KB）- **无开销甚至更快**
- ✅ 批量上传相同内容
- ✅ 需要节省存储空间的场景

**推荐使用：**
- ✅ 中等文件上传（100KB - 1MB）- **开销极小（< 2%）**
- ✅ 大文件上传（> 1MB）- **开销可接受（< 14%）**

**配置选项：**
```bash
# 启用/禁用秒传（默认启用）
export ORCAS_INSTANT_UPLOAD_ENABLED=true

# 通过SDK Config配置（优先级高于环境变量）
# RefLevel: 0=OFF, 1=FULL, 2=FAST
```

## 总结

S3服务展现出：

- ✅ **优秀的并发扩展性**：100并发操作提升45.9倍
- ✅ **高效的批量写入优化**：小文件（≤ 64KB）自动优化，性能提升11-180%
- ✅ **秒传性能优势**：去重场景下性能提升31-46%，非去重场景小文件无开销甚至更快
- ✅ **低延迟**：高并发下平均延迟低至1.29ms
- ✅ **高吞吐量**：100并发操作达到773.86 MB/s
- ✅ **稳定性能**：不同对象大小下性能一致
- ✅ **可配置优化**：可根据工作负载需求启用/禁用批量写入和秒传

S3服务已可用于生产环境，适合高并发对象存储场景。批量写入优化**强烈推荐用于小文件工作负载（≤ 64KB）**，在所有并发级别下可提供11-180%的性能提升（1.1-2.8倍）。

**秒传功能**在所有场景下都推荐启用：
- **去重场景**：性能提升31-46%，内存分配减少58%
- **非去重场景**：小文件（< 100KB）无开销甚至更快，中等文件开销极小（< 2%），大文件开销可接受（< 14%）
- **配置优化**：使用ecache缓存配置后，性能进一步优化

## HTTP/2支持

### 当前状态

当前性能测试使用**HTTP/1.1**协议（通过Go的`httptest`包）。HTTP/2支持目前未在测试框架中实现，原因如下：

1. **HTTP/2需要TLS**：HTTP/2要求TLS加密（某些情况下h2c除外）
2. **httptest限制**：Go的`httptest`包本身不支持HTTP/2
3. **测试复杂性**：HTTP/2测试需要TLS证书设置和配置

### HTTP/2测试可能性

**是的，HTTP/2测试是可能的**，但需要：

1. **TLS配置**：生成自签名证书用于测试
2. **HTTP/2服务器设置**：使用`golang.org/x/net/http2`包
3. **客户端配置**：配置支持TLS的HTTP/2客户端

**HTTP/2的潜在优势：**
- **多路复用**：在单个连接上处理多个请求
- **头部压缩**：减少重复头部的开销
- **服务器推送**：主动数据交付的潜力
- **更好的并发性**：改善并发请求的性能

**实现方法：**
```go
// HTTP/2测试设置示例（伪代码）
import (
    "golang.org/x/net/http2"
    "crypto/tls"
)

// 创建TLS配置
tlsConfig := &tls.Config{
    NextProtos: []string{"h2"},
}

// 配置HTTP/2服务器
server := &http.Server{
    TLSConfig: tlsConfig,
}
http2.ConfigureServer(server, &http2.Server{})
```

**注意**：HTTP/2测试需要额外的设置，可能显示不同的性能特征，特别是对于并发操作。

